<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Phase Grouped Timeline with Enhanced Styling, Settings & Total Analysis</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.css" />
  <!-- Include Choices.js CSS for dependency and phase dropdowns -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" />
  <style>
    :root {
      --phase-bg: #f0f0f0;
      --phase-stroke: #ccc;
    }
    
    body {
      font-family: Arial, sans-serif;
      background: #fafafa;
      margin: 0;
      padding: 0;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      position: relative;
    }
    
    /* Toolbar styling using Flexbox with left, center, and right groups */
    .toolbar {
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .left-buttons,
    .right-buttons {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .date-display {
      flex: 1;
      text-align: center;
      font-size: 16px;
      font-weight: bold;
    }
    
    .toolbar button {
      background: linear-gradient(to right, #f0f0f0, #e0e0e0);
      border: none;
      padding: 10px 16px;
      border-radius: 4px;
      transition: background 0.3s ease, transform 0.3s ease;
      font-size: 14px;
      cursor: pointer;
    }
    
    .toolbar button:hover {
      background: linear-gradient(to right, #e0e0e0, #d0d0d0);
      transform: translateY(-2px);
    }
    
    .view-mode-group button {
      background: linear-gradient(to right, #f0f0f0, #e0e0e0);
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      transition: background 0.3s ease, transform 0.3s ease;
      font-size: 13px;
      cursor: pointer;
    }
    
    .view-mode-group button:hover {
      background: linear-gradient(to right, #e0e0e0, #d0d0d0);
      transform: translateY(-2px);
    }
    
    /* Settings Container */
    .settings-container {
      position: relative;
      display: inline-block;
    }
    
    .settings-button {
      background: none;
      border: none;
      font-size: 22px;
      cursor: pointer;
      padding: 5px;
    }
    
    /* Settings dropdown positioned below its container */
    .settings-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 5px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      display: none;
      z-index: 1001;
      min-width: 150px;
    }
    
    .settings-dropdown.show {
      display: block;
    }
    
    /* Export JSON button styling in dropdown */
    .settings-dropdown button {
      background: linear-gradient(to right, #f0f0f0, #e0e0e0);
      border: none;
      padding: 10px 16px;
      border-radius: 4px;
      transition: background 0.3s ease, transform 0.3s ease;
      font-size: 14px;
      cursor: pointer;
      width: 100%;
      text-align: left;
    }
    
    .settings-dropdown button:hover {
      background: linear-gradient(to right, #e0e0e0, #d0d0d0);
      transform: translateY(-2px);
    }
    
    /* Additional styling for file info text in settings */
    #autoSaveFileInfo {
      padding: 10px;
      font-size: 12px;
      color: #555;
    }
    
    /* Modal (Task Pop-up) Enhancements */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
    }
    
    .modal-content {
      background: #fff;
      padding: 25px;
      width: 650px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .modal-content h2 {
      font-size: 24px;
      margin-bottom: 15px;
      border-bottom: 1px solid #ccc;
      padding-bottom: 10px;
    }
    
    /* Horizontal Form Layout (for Task Add/Edit) */
    .form-horizontal {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .form-horizontal .form-group {
      display: flex;
      flex-direction: column;
    }
    
    .form-horizontal .form-group.full-width {
      grid-column: span 2;
    }
    
    .form-horizontal .button-group {
      grid-column: span 2;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .form-group label {
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .form-group input,
    .form-group textarea,
    .form-group select {
      padding: 6px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    
    /* Phase Header Styling */
    .phase-header rect {
      fill: var(--phase-bg) !important;
      stroke: var(--phase-stroke) !important;
      height: 40px !important;
    }
    
    /* Ensure phase header text is visible */
    .phase-header text {
      fill: #333 !important;
      font-size: 14px !important;
      font-weight: bold !important;
    }
    
    /* Smooth transition for Gantt bars */
    .gantt .bar-wrapper rect {
      transition: fill 0.3s ease;
    }
    
    /* Style for Delay Overlays */
    .delay-overlay {
      fill: red;
      opacity: 0.5;
      pointer-events: none;
    }
    
    /* Analysis Panel (Total Analysis) Styling */
    #analysisPanel {
      margin-top: 20px;
      padding: 15px;
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 4px;
    }
    
    #analysisPanel h3 {
      margin-top: 0;
    }
    
    /* Single Bar Analysis (Horizontal Bar) */
    #analysisBar {
      width: 100%;
      height: 30px;
      display: flex;
      margin-top: 15px;
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
    }
    #analysisBar > div {
      height: 100%;
    }
    
    /* Modal Button Styling */
    .modal-content .button-group button {
      background: linear-gradient(to right, #f0f0f0, #e0e0e0);
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      transition: background 0.3s ease, transform 0.3s ease;
      cursor: pointer;
    }
    
    .modal-content .button-group button:hover {
      background: linear-gradient(to right, #e0e0e0, #d0d0d0);
      transform: translateY(-2px);
    }
    
    /* Add margin to the Gantt chart container */
    #gantt {
      margin-top: 50px;
    }

    /* ---- Context Menu Styles ---- */
    #contextMenu {
      position: absolute;
      display: none;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      z-index: 2000;
      width: 150px;
      padding: 0;
    }
    #contextMenu ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    #contextMenu li {
      padding: 8px 12px;
      cursor: pointer;
    }
    #contextMenu li:hover {
      background: #e0e0e0;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Toolbar with left, center, and right groups -->
    <div class="toolbar">
      <div class="left-buttons">
        <!-- Standard Add Task button -->
        <button onclick="openModal(null)">Add Task</button>
      </div>
      <div class="date-display" id="dateDisplay"></div>
      <div class="right-buttons">
        <div class="view-mode-group">
          <button id="btn-day" onclick="changeView('Day')" class="active">Day</button>
          <button id="btn-week" onclick="changeView('Week')">Week</button>
          <button id="btn-month" onclick="changeView('Month')">Month</button>
          <button id="btn-year" onclick="changeView('Year')">Year</button>
        </div>
        <div class="settings-container">
          <button class="settings-button" onclick="toggleSettings()">&#9881;</button>
          <div class="settings-dropdown" id="settingsDropdown">
            <button onclick="exportData()">Export JSON</button>
            <!-- Display current auto-save file info -->
            <div id="autoSaveFileInfo">Auto Save File: None</div>
            <button onclick="loadAndSetAutoSaveFile()">Set/Change Auto Save File</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Gantt chart container -->
    <div id="gantt"></div>
    
    <!-- Analysis Panel with Total Analysis and Single Bar -->
    <div id="analysisPanel">
      <h3>Total Analysis</h3>
      <p id="totalTasks">Total Tasks Planned: 0</p>
      <p id="inProgressTasks">Tasks In Progress: 0</p>
      <p id="completedTasks">Tasks Completed: 0</p>
      <p id="notYetStarted">Tasks Not Yet Started: 0</p>
      <p id="blockedTasks">Tasks Blocked: 0</p>
      <p id="delayedTasks">Number of Delayed Tasks: 0</p>
      <p id="totalDelay">Total Delay Days: 0</p>
      <div id="analysisBar"></div>
    </div>
    
    <!-- Edit Task Modal (Horizontal Form Layout) -->
    <div class="modal" id="taskModal">
      <div class="modal-content">
        <h2 id="modalTitle">Create New Task</h2>
        <form id="taskForm" class="form-horizontal">
          <!-- Replace phase select with an input and datalist -->
          <div class="form-group">
            <label for="phaseName">Phase Name (optional):</label>
            <input type="text" id="phaseName" list="phaseList" />
            <datalist id="phaseList"></datalist>
          </div>
          
          <div class="form-group">
            <label for="taskName">Task Name:</label>
            <input type="text" id="taskName" required />
          </div>
          <div class="form-group">
            <label for="taskStart">Planned Start Date:</label>
            <input type="date" id="taskStart" required />
          </div>
          <div class="form-group">
            <label for="taskEnd">Planned End Date:</label>
            <input type="date" id="taskEnd" required />
          </div>
          <div class="form-group">
            <label for="actualStart">Actual Start Date:</label>
            <input type="date" id="actualStart" />
          </div>
          <div class="form-group">
            <label for="actualEnd">Actual End Date:</label>
            <input type="date" id="actualEnd" />
          </div>
          <!-- Status dropdown with fixed style choices -->
          <div class="form-group">
            <label for="taskStatus">Status:</label>
            <select id="taskStatus">
              <option value="not_started">Not Yet Started</option>
              <option value="in_progress">In Progress</option>
              <option value="completed">Completed</option>
              <option value="blocked">Blocked</option>
            </select>
          </div>
          <div class="form-group full-width">
            <label for="taskDependencies">Dependencies:</label>
            <!-- This select will be converted into a multi-select dropdown via Choices.js -->
            <select id="taskDependencies" multiple>
              <option value="">Select Dependencies</option>
            </select>
          </div>
          <div class="form-group full-width">
            <label for="taskNotes">Notes:</label>
            <textarea id="taskNotes" rows="4"></textarea>
          </div>
          <div class="button-group">
            <button type="submit">Save Task</button>
            <button type="button" onclick="closeModal()">Cancel</button>
          </div>
        </form>
      </div>
    </div>
    
    <!-- Task Details Modal (Vertical Layout remains unchanged) -->
    <div class="modal" id="detailsModal">
      <div class="modal-content">
        <h2 id="detailsTaskTitle">Task Details</h2>
        <p><strong>Phase:</strong> <span id="detailsPhase"></span></p>
        <p><strong>Planned Start:</strong> <span id="detailsStart"></span></p>
        <p><strong>Planned End:</strong> <span id="detailsEnd"></span></p>
        <p><strong>Actual Start:</strong> <span id="detailsActualStart"></span></p>
        <p><strong>Actual End:</strong> <span id="detailsActualEnd"></span></p>
        <p><strong>Status:</strong> <span id="detailsStatus"></span></p>
        <p><strong>Dependencies:</strong> <span id="detailsDependencies"></span></p>
        <p><strong>Notes:</strong></p>
        <p id="detailsNotes" style="white-space: pre-wrap; background:#f9f9f9; padding:8px; border:1px solid #ddd;"></p>
        <div class="button-group">
          <button id="editTaskButton" onclick="editTaskFromDetails(this.getAttribute('data-task-id'));">Edit Task</button>
          <button id="deleteTaskButton" onclick="deleteTask(this.getAttribute('data-task-id'));">Delete Task</button>
          <button type="button" onclick="closeDetailsModal()">Close</button>
        </div>
      </div>
    </div>

    <!-- Custom Context Menu (will be dynamically populated) -->
    <div id="contextMenu"></div>
    
  </div>
  
  <!-- Include Frappe Gantt -->
  <script src="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>
  <!-- Include Choices.js library for dependency and phase dropdowns -->
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <script>
    // Global variables
    let tasks = [];
    let currentEditId = null;
    let fileHandle = null; // Holds the writable file handle for auto-saving
    let currentViewMode = 'Day';
    
    // Mapping of statuses to colors and labels.
    const statusColors = {
      not_started: "#808080",  // Gray
      in_progress: "#F9A825",  // Darker Yellow
      completed:   "#008000",  // Green
      blocked:     "#FF0000"   // Red
    };
    const statusLabels = {
      not_started: "Not Yet Started",
      in_progress: "In Progress",
      completed:   "Completed",
      blocked:     "Blocked"
    };
    
    // Auto-load tasks from localStorage.
    const savedTasks = localStorage.getItem('tasks');
    if (savedTasks) {
      tasks = JSON.parse(savedTasks);
    }
    
    // Save tasks to localStorage and, if available, to the designated auto-save file.
    async function saveTasks() {
      localStorage.setItem('tasks', JSON.stringify(tasks));
      if (fileHandle) {
        try {
          if (await fileHandle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
            const permission = await fileHandle.requestPermission({ mode: 'readwrite' });
            if (permission !== 'granted') {
              console.error('Write permission was not granted.');
              return;
            }
          }
          const writable = await fileHandle.createWritable();
          await writable.write(JSON.stringify(tasks, null, 2));
          await writable.close();
          console.log('Auto-saved to file.');
        } catch (err) {
          console.error('Error writing to file:', err);
        }
      }
    }
    
    // Use the File System Access API to load a file and set it as the auto-save file.
    async function loadAndSetAutoSaveFile() {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'JSON Files',
            accept: { 'application/json': ['.json'] }
          }],
          multiple: false
        });
        const permission = await handle.requestPermission({ mode: 'readwrite' });
        if (permission !== 'granted') {
          console.error('Write permission was not granted.');
          return;
        }
        fileHandle = handle;
        updateAutoSaveFileInfo();
        const fileData = await handle.getFile();
        const text = await fileData.text();
        if (!text || text.trim() === "") {
          console.log("Loaded file is empty. Clearing tasks.");
          tasks = [];
        } else {
          try {
            tasks = JSON.parse(text);
            console.log('Loaded tasks from file.');
          } catch (e) {
            console.error('File does not contain valid JSON. Starting with empty task list.');
            tasks = [];
          }
        }
        renderGantt();
      } catch (err) {
        console.error('Error loading file:', err);
      }
    }
    
    // Update the file info display in the settings dropdown.
    function updateAutoSaveFileInfo() {
      const info = document.getElementById('autoSaveFileInfo');
      if (fileHandle && fileHandle.name) {
        info.textContent = "Auto Save File: " + fileHandle.name;
      } else {
        info.textContent = "Auto Save File: None";
      }
    }
    
    // Toggle settings dropdown visibility.
    function toggleSettings() {
      const dropdown = document.getElementById('settingsDropdown');
      dropdown.classList.toggle('show');
    }
    
    // Helper function to add ordinal suffix to a day.
    function getOrdinal(n) {
      const s = ["th", "st", "nd", "rd"];
      const v = n % 100;
      return n + (s[(v - 20) % 10] || s[v] || s[0]);
    }
    
    // Format a Date object as "Month DayOrdinal, Year"
    function formatDate(date) {
      const month = new Intl.DateTimeFormat('en-US', { month: 'long' }).format(date);
      const day = date.getDate();
      const year = date.getFullYear();
      return `${month} ${getOrdinal(day)}, ${year}`;
    }
    
    // Update populatePhaseSelect to fill the datalist.
    function populatePhaseSelect() {
      const phaseList = document.getElementById('phaseList');
      phaseList.innerHTML = '';
      const phases = [...new Set(tasks.map(task => task.phase).filter(Boolean))];
      phases.forEach(phase => {
        const option = document.createElement('option');
        option.value = phase;
        phaseList.appendChild(option);
      });
    }
    
    // Open the edit modal; pre-populate if editing an existing task.
    function openModal(taskId) {
      currentEditId = taskId;
      const modalTitle = document.getElementById('modalTitle');
      if (taskId) {
        modalTitle.textContent = "Edit Task";
        const task = tasks.find(t => t.id === taskId);
        document.getElementById('phaseName').value = task.phase || "";
        document.getElementById('taskName').value = task.name;
        document.getElementById('taskStart').value = task.start;
        document.getElementById('taskEnd').value = task.end;
        document.getElementById('actualStart').value = task.actualStart || "";
        document.getElementById('actualEnd').value = task.actualEnd || "";
        document.getElementById('taskNotes').value = task.notes || "";
        document.getElementById('taskStatus').value = task.status || "not_started";
      } else {
        modalTitle.textContent = "Create New Task";
        document.getElementById('taskForm').reset();
        document.getElementById('taskStatus').value = "not_started";
      }
      populatePhaseSelect();
      populateDependencies();
      document.getElementById('taskModal').style.display = 'block';
    }
    
    function closeModal() {
      document.getElementById('taskModal').style.display = 'none';
      currentEditId = null;
    }
    
    // Populate the dependencies dropdown; exclude the current task if editing.
    function populateDependencies() {
      const select = document.getElementById('taskDependencies');
      select.innerHTML = '<option value="">Select Dependencies</option>';
      tasks.forEach(task => {
        if (currentEditId && task.id === currentEditId) return;
        const option = document.createElement('option');
        option.value = task.id;
        option.textContent = task.phase ? `${task.phase} - ${task.name}` : task.name;
        select.appendChild(option);
      });
      if (window.dependencyChoices) {
        window.dependencyChoices.destroy();
      }
      window.dependencyChoices = new Choices(select, {
        removeItemButton: true,
        shouldSort: false
      });
    }

    // Helper: Format a Date object as "YYYY-MM-DD"
    function formatDateForGantt(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    // Helper: When no real tasks exist, update the analysis panel to show zeros.
    function updateAnalysisPanelEmpty() {
      document.getElementById('totalTasks').textContent = "Total Tasks Planned: 0";
      document.getElementById('inProgressTasks').textContent = "Tasks In Progress: 0";
      document.getElementById('completedTasks').textContent = "Tasks Completed: 0";
      document.getElementById('notYetStarted').textContent = "Tasks Not Yet Started: 0";
      document.getElementById('blockedTasks').textContent = "Tasks Blocked: 0";
      document.getElementById('delayedTasks').textContent = "Number of Delayed Tasks: 0";
      document.getElementById('totalDelay').textContent = "Total Delay Days: 0";
      document.getElementById('analysisBar').innerHTML = '';
    }

    // Updated renderGantt() function
    function renderGantt() {
      const ganttEl = document.getElementById('gantt');
      ganttEl.innerHTML = '';

      // Determine the tasks to display:
      // If there are no real tasks, create a dummy task that spans from today to tomorrow.
      let tasksForGantt = [];
      if (tasks.length === 0) {
        const today = new Date();
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1);
        tasksForGantt.push({
          id: 'dummy',
          name: 'No Tasks',
          start: formatDateForGantt(today),
          end: formatDateForGantt(tomorrow),
          progress: 0,
          custom_class: 'dummy-task',
          isDummy: true
        });
      } else {
        // Otherwise, work with your real tasks.
        tasksForGantt = tasks.slice();
      }

      // Group tasks into phases (if applicable) and also gather ungrouped tasks.
      const phases = {};
      const ungroupedTasks = [];
      tasksForGantt.forEach(task => {
        if (task.isDummy) {
          ungroupedTasks.push(task);
        } else if (task.phase) {
          if (!phases[task.phase]) {
            phases[task.phase] = { color: task.color, tasks: [] };
          }
          phases[task.phase].tasks.push(task);
        } else {
          ungroupedTasks.push(task);
        }
      });

      // Build the formatted tasks list for Frappe Gantt.
      const formattedTasks = [];
      Object.entries(phases).forEach(([phaseName, phaseData]) => {
        formattedTasks.push({
          id: `phase-${phaseName}`,
          name: phaseName,
          start: getEarliestStart(phaseData.tasks),
          end: getLatestEnd(phaseData.tasks),
          progress: 0,
          custom_class: 'phase-header',
          isHeader: true
        });
        phaseData.tasks.forEach(task => {
          formattedTasks.push({
            id: task.id,
            name: task.name,
            start: task.start,
            end: task.end,
            dependencies: (task.dependencies || []).join(', '),
            progress: 0,
            color: task.color,
            custom_class: `task-${task.id}`
          });
        });
      });
      ungroupedTasks.forEach(task => {
        formattedTasks.push({
          id: task.id,
          name: task.name,
          start: task.start,
          end: task.end,
          dependencies: (task.dependencies || []).join(', '),
          progress: 0,
          color: task.color,
          custom_class: `task-${task.id}`
        });
      });

      // Create the Gantt chart.
      const gantt = new Gantt('#gantt', formattedTasks, {
        view_mode: currentViewMode,
        on_click: (task) => {
          if (task.isHeader) return;
          if (task.id === 'dummy') return; // Ignore clicks on the dummy task.
          showTaskDetails(task.id);
        },
        on_date_change: async (task, start, end) => {
          if (task.id === 'dummy') return; // Ignore date changes for the dummy task.
          const updatedTask = tasks.find(t => t.id === task.id);
          if (updatedTask) {
            updatedTask.start = start;
            updatedTask.end = end;
            await saveTasks();
            renderGantt();
          }
        }
      });

      // Append custom styles for task colors.
      const style = document.createElement('style');
      tasksForGantt.forEach(task => {
        if (task.isDummy) {
          style.innerHTML += `
            .task-dummy rect.bar {
              fill: transparent !important;
              stroke: transparent !important;
            }
            .dummy-task {
              pointer-events: none;
            }
          `;
        } else {
          style.innerHTML += `
            .task-${task.id} rect.bar {
              fill: ${task.color} !important;
              stroke: ${task.color} !important;
            }
            .task-${task.id} rect.bar-progress {
              fill: ${task.color} !important;
            }
          `;
        }
      });
      ganttEl.appendChild(style);

      // Update the analysis panel.
      if (tasks.length === 0) {
        updateAnalysisPanelEmpty();
      } else {
        updateAnalysisPanel();
      }
    }

    function getEarliestStart(tasks) {
      return tasks.reduce((min, task) => task.start < min ? task.start : min, tasks[0].start);
    }
    function getLatestEnd(tasks) {
      return tasks.reduce((max, task) => task.end > max ? task.end : max, tasks[0].end);
    }
    
    // Draw red overlays for delay differences.
    function addDelayOverlays() {
      const svg = document.querySelector('#gantt svg');
      if (!svg) return;
      svg.querySelectorAll('.delay-overlay').forEach(el => el.remove());
      tasks.forEach(task => {
        if (!task.start || !task.end) return;
        const plannedStart = new Date(task.start);
        const plannedEnd = new Date(task.end);
        const actualStart = task.actualStart ? new Date(task.actualStart) : null;
        const actualEnd = task.actualEnd ? new Date(task.actualEnd) : null;
        const barRect = document.querySelector(`.task-${task.id} rect.bar`);
        if (!barRect) return;
        const barX = parseFloat(barRect.getAttribute('x'));
        const barWidth = parseFloat(barRect.getAttribute('width'));
        const barY = parseFloat(barRect.getAttribute('y'));
        const barHeight = parseFloat(barRect.getAttribute('height'));
        const plannedDuration = (plannedEnd - plannedStart) / 86400000;
        if (plannedDuration <= 0) return;
        const dayWidth = barWidth / plannedDuration;
        if (actualStart && actualStart > plannedStart) {
          const delayStartDays = (actualStart - plannedStart) / 86400000;
          const overlayWidth = delayStartDays * dayWidth;
          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", barX);
          rect.setAttribute("y", barY);
          rect.setAttribute("width", overlayWidth);
          rect.setAttribute("height", barHeight);
          rect.setAttribute("class", "delay-overlay");
          svg.appendChild(rect);
        }
        if (actualEnd && actualEnd > plannedEnd) {
          const delayEndDays = (actualEnd - plannedEnd) / 86400000;
          const overlayWidth = delayEndDays * dayWidth;
          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", barX + barWidth);
          rect.setAttribute("y", barY);
          rect.setAttribute("width", overlayWidth);
          rect.setAttribute("height", barHeight);
          rect.setAttribute("class", "delay-overlay");
          svg.appendChild(rect);
        }
      });
    }
    
    // Update the analysis panel with task metrics.
    function updateAnalysisPanel() {
      const totalTasks = tasks.length;
      const notYetStarted = tasks.filter(t => t.status === "not_started").length;
      const inProgress = tasks.filter(t => t.status === "in_progress").length;
      const completed = tasks.filter(t => t.status === "completed").length;
      const blocked = tasks.filter(t => t.status === "blocked").length;
      let delayedCount = 0;
      let totalDelay = 0;
      tasks.forEach(task => {
        const plannedStart = new Date(task.start);
        const plannedEnd = new Date(task.end);
        let taskDelay = 0;
        if (task.actualStart) {
          const actualStart = new Date(task.actualStart);
          if (actualStart > plannedStart) {
            taskDelay += (actualStart - plannedStart) / 86400000;
          }
        }
        if (task.actualEnd) {
          const actualEnd = new Date(task.actualEnd);
          if (actualEnd > plannedEnd) {
            taskDelay += (actualEnd - plannedEnd) / 86400000;
          }
        }
        if (taskDelay > 0) {
          delayedCount++;
          totalDelay += taskDelay;
        }
      });
      document.getElementById('totalTasks').textContent = "Total Tasks Planned: " + totalTasks;
      document.getElementById('inProgressTasks').textContent = "Tasks In Progress: " + inProgress;
      document.getElementById('completedTasks').textContent = "Tasks Completed: " + completed;
      document.getElementById('notYetStarted').textContent = "Tasks Not Yet Started: " + notYetStarted;
      document.getElementById('blockedTasks').textContent = "Tasks Blocked: " + blocked;
      document.getElementById('delayedTasks').textContent = "Number of Delayed Tasks: " + delayedCount;
      document.getElementById('totalDelay').textContent = "Total Delay Days: " + totalDelay.toFixed(1);
      
      const analysisBar = document.getElementById('analysisBar');
      if (totalTasks > 0) {
        const notYetStartedPercent = (notYetStarted / totalTasks) * 100;
        const inProgressPercent = (inProgress / totalTasks) * 100;
        const completedPercent = (completed / totalTasks) * 100;
        const blockedPercent = (blocked / totalTasks) * 100;
        analysisBar.innerHTML = `
          <div title="Not Yet Started: ${notYetStarted}" style="width: ${notYetStartedPercent}%; background: ${statusColors.not_started};"></div>
          <div title="In Progress: ${inProgress}" style="width: ${inProgressPercent}%; background: ${statusColors.in_progress};"></div>
          <div title="Completed: ${completed}" style="width: ${completedPercent}%; background: ${statusColors.completed};"></div>
          <div title="Blocked: ${blocked}" style="width: ${blockedPercent}%; background: ${statusColors.blocked};"></div>
        `;
      } else {
        analysisBar.innerHTML = '';
      }
    }
    
    // Handle task form submission.
    document.getElementById('taskForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      const status = document.getElementById('taskStatus').value;
      const color = statusColors[status];
      const taskData = {
        id: currentEditId || Date.now().toString(),
        phase: document.getElementById('phaseName').value || null,
        name: document.getElementById('taskName').value,
        start: document.getElementById('taskStart').value,
        end: document.getElementById('taskEnd').value,
        actualStart: document.getElementById('actualStart').value || null,
        actualEnd: document.getElementById('actualEnd').value || null,
        status: status,
        color: color,
        dependencies: Array.from(document.getElementById('taskDependencies').selectedOptions)
                      .map(option => option.value)
                      .filter(Boolean),
        notes: document.getElementById('taskNotes').value
      };
      if (currentEditId) {
        const index = tasks.findIndex(t => t.id === currentEditId);
        tasks[index] = taskData;
      } else {
        tasks.push(taskData);
      }
      await saveTasks();
      closeModal();
      renderGantt();
    });
    
    // Switch view mode.
    function changeView(mode) {
      currentViewMode = mode;
      ['Day','Week','Month','Year'].forEach(m => {
        document.getElementById('btn-' + m.toLowerCase()).classList.toggle('active', m === mode);
      });
      renderGantt();
    }
    
    // Task Details Modal Functions.
    function showTaskDetails(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      document.getElementById('detailsTaskTitle').textContent = task.name;
      document.getElementById('detailsPhase').textContent = task.phase || 'None';
      document.getElementById('detailsStart').textContent = task.start;
      document.getElementById('detailsEnd').textContent = task.end;
      document.getElementById('detailsActualStart').textContent = task.actualStart || 'N/A';
      document.getElementById('detailsActualEnd').textContent = task.actualEnd || 'N/A';
      document.getElementById('detailsStatus').textContent = statusLabels[task.status] || task.status;
      const dependencyNames = task.dependencies && task.dependencies.length 
        ? task.dependencies.map(depId => {
            const depTask = tasks.find(t => t.id === depId);
            return depTask ? depTask.name : depId;
          }).join(', ')
        : 'None';
      document.getElementById('detailsDependencies').textContent = dependencyNames;
      document.getElementById('detailsNotes').textContent = task.notes || 'No notes';
      document.getElementById('editTaskButton').setAttribute('data-task-id', taskId);
      document.getElementById('deleteTaskButton').setAttribute('data-task-id', taskId);
      document.getElementById('detailsModal').style.display = 'block';
    }
    
    function closeDetailsModal() {
      document.getElementById('detailsModal').style.display = 'none';
    }
    
    function editTaskFromDetails(taskId) {
      closeDetailsModal();
      openModal(taskId);
    }
    
    // Delete task functionality.
    function deleteTask(taskId) {
      if (!confirm("Are you sure you want to delete this task?")) return;
      tasks = tasks.filter(t => t.id !== taskId);
      tasks.forEach(task => {
        if (task.dependencies && task.dependencies.length) {
          task.dependencies = task.dependencies.filter(depId => depId !== taskId);
        }
      });
      saveTasks().then(() => {
        closeDetailsModal();
        renderGantt();
      });
    }
    
    // ---- New Functionality: Custom Context Menu on Right-Click ----
    
    // Utility: Close the context menu.
    function closeContextMenu() {
      const contextMenu = document.getElementById('contextMenu');
      contextMenu.style.display = 'none';
    }
    
    // Utility: Dynamically show context menu with options depending on whether a task was right-clicked.
    function showContextMenu(pos, taskId) {
      const contextMenu = document.getElementById('contextMenu');
      
      if (taskId) {
        // If a task was right-clicked, show Edit/Delete options.
        contextMenu.innerHTML = `
          <ul>
            <li id="editTaskOption">Edit Task</li>
            <li id="deleteTaskOption">Delete Task</li>
          </ul>
        `;
        document.getElementById('editTaskOption').addEventListener('click', function(e) {
          closeContextMenu();
          openModal(taskId);
        });
        document.getElementById('deleteTaskOption').addEventListener('click', function(e) {
          closeContextMenu();
          deleteTask(taskId);
        });
      } else {
        // Otherwise, show the "Add Task" option.
        contextMenu.innerHTML = `
          <ul>
            <li id="addTaskOption">Add Task</li>
          </ul>
        `;
        document.getElementById('addTaskOption').addEventListener('click', function(e) {
          closeContextMenu();
          openModal(null);
        });
      }
      // Position the context menu exactly at the computed relative coordinates.
      contextMenu.style.top = pos.pageY + 'px';
      contextMenu.style.left = pos.pageX + 'px';
      contextMenu.style.display = 'block';
    }

    
    // Listen for the contextmenu event (right-click) on the Gantt area.
    document.getElementById('gantt').addEventListener('contextmenu', function(event) {
      event.preventDefault(); // Prevent the default browser context menu.
      
      let taskId = null;
      // Traverse the event's composed path (or fallback) to check if a task element was right-clicked.
      const path = event.composedPath ? event.composedPath() : (event.path || []);
      for (let el of path) {
        if (el.classList) {
          const taskClass = Array.from(el.classList).find(cls => cls.startsWith('task-'));
          if (taskClass) {
            taskId = taskClass.substring(5); // Remove the "task-" prefix.
            break;
          }
        }
      }
      
      // Compute the click coordinates relative to the container.
      const container = document.querySelector('.container');
      const containerRect = container.getBoundingClientRect();
      // Use event.clientX/Y (relative to the viewport) minus the container's left/top.
      const relativeX = event.clientX - containerRect.left;
      const relativeY = event.clientY - containerRect.top;
      
      // Create a simple coordinate object (with properties named pageX/pageY for compatibility)
      const pos = { pageX: relativeX, pageY: relativeY };
      
      showContextMenu(pos, taskId);
    });

    
    // Hide the context menu when clicking anywhere else.
    document.addEventListener('click', function(event) {
      const contextMenu = document.getElementById('contextMenu');
      if (contextMenu.style.display === 'block') {
        closeContextMenu();
      }
    });
    
    // Set today's date in the toolbar on DOM load.
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('dateDisplay').textContent = formatDate(new Date());
      window.dependencyChoices = new Choices(document.getElementById('taskDependencies'), {
        removeItemButton: true,
        shouldSort: false
      });
      populatePhaseSelect();
      updateAutoSaveFileInfo();
    });
    function exportData() {
      const dataStr = JSON.stringify(tasks, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tasks.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    // Initial rendering.
    renderGantt();
  </script>
</body>
</html>
