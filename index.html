<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Phase Grouped Timeline with Enhanced Styling & Settings</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.css" />
  <style>
    :root {
      --phase-bg: #f0f0f0;
      --phase-stroke: #ccc;
    }
    
    body {
      font-family: Arial, sans-serif;
      background: #fafafa;
      margin: 0;
      padding: 0;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      position: relative;
    }
    
    /* Toolbar styling using Flexbox with left, center, and right groups */
    .toolbar {
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .left-buttons,
    .right-buttons {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .date-display {
      flex: 1;
      text-align: center;
      font-size: 16px;
      font-weight: bold;
    }
    
    .toolbar button {
      background: linear-gradient(to right, #f0f0f0, #e0e0e0);
      border: none;
      padding: 10px 16px;
      border-radius: 4px;
      transition: background 0.3s ease, transform 0.3s ease;
      font-size: 14px;
      cursor: pointer;
    }
    
    .toolbar button:hover {
      background: linear-gradient(to right, #e0e0e0, #d0d0d0);
      transform: translateY(-2px);
    }
    
    .view-mode-group button {
      background: linear-gradient(to right, #f0f0f0, #e0e0e0);
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      transition: background 0.3s ease, transform 0.3s ease;
      font-size: 13px;
      cursor: pointer;
    }
    
    .view-mode-group button:hover {
      background: linear-gradient(to right, #e0e0e0, #d0d0d0);
      transform: translateY(-2px);
    }
    
    /* Settings Container */
    .settings-container {
      position: relative;
      display: inline-block;
    }
    
    .settings-button {
      background: none;
      border: none;
      font-size: 22px;
      cursor: pointer;
      padding: 5px;
    }
    
    /* Settings dropdown now positioned below its container */
    .settings-dropdown {
      position: absolute;
      top: 100%;  /* directly below the button */
      right: 0;
      margin-top: 5px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      display: none;
      z-index: 1001;
      min-width: 150px;
    }
    
    .settings-dropdown.show {
      display: block;
    }
    
    /* Export JSON button styling in dropdown */
    .settings-dropdown button {
      background: linear-gradient(to right, #f0f0f0, #e0e0e0);
      border: none;
      padding: 10px 16px;
      border-radius: 4px;
      transition: background 0.3s ease, transform 0.3s ease;
      font-size: 14px;
      cursor: pointer;
      width: 100%;
      text-align: left;
    }
    
    .settings-dropdown button:hover {
      background: linear-gradient(to right, #e0e0e0, #d0d0d0);
      transform: translateY(-2px);
    }
    
    /* Modal (Task Pop-up) Enhancements */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
    }
    
    .modal-content {
      background: #fff;
      padding: 25px;
      width: 650px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .modal-content h2 {
      font-size: 24px;
      margin-bottom: 15px;
      border-bottom: 1px solid #ccc;
      padding-bottom: 10px;
    }
    
    /* Horizontal Form Layout (for Task Add/Edit) */
    .form-horizontal {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .form-horizontal .form-group {
      display: flex;
      flex-direction: column;
    }
    
    .form-horizontal .form-group.full-width {
      grid-column: span 2;
    }
    
    .form-horizontal .button-group {
      grid-column: span 2;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .form-group label {
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .form-group input,
    .form-group textarea,
    .form-group select {
      padding: 6px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    
    /* Phase Header Styling */
    .phase-header rect {
      fill: var(--phase-bg) !important;
      stroke: var(--phase-stroke) !important;
      height: 40px !important;
    }
    
    /* Ensure phase header text is visible */
    .phase-header text {
      fill: #333 !important;
      font-size: 14px !important;
      font-weight: bold !important;
    }
    
    /* Smooth transition for Gantt bars */
    .gantt .bar-wrapper rect {
      transition: fill 0.3s ease;
    }
    
    /* Style for Delay Overlays */
    .delay-overlay {
      fill: red;
      opacity: 0.5;
      pointer-events: none;
    }
    
    /* Analysis Panel Styling */
    #analysisPanel {
      margin-top: 20px;
      padding: 15px;
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 4px;
    }
    
    #analysisPanel h3 {
      margin-top: 0;
    }
    
    /* Modal Button Styling */
    .modal-content .button-group button {
      background: linear-gradient(to right, #f0f0f0, #e0e0e0);
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      transition: background 0.3s ease, transform 0.3s ease;
      cursor: pointer;
    }
    
    .modal-content .button-group button:hover {
      background: linear-gradient(to right, #e0e0e0, #d0d0d0);
      transform: translateY(-2px);
    }
    
    /* Add margin to the Gantt chart container to prevent crowding by the dropdown */
    #gantt {
      margin-top: 50px;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Toolbar with left, center, and right groups -->
    <div class="toolbar">
      <div class="left-buttons">
        <button onclick="openModal(null)">Add Task</button>
        <button onclick="loadAndSetAutoSaveFile()">Load/Set Auto Save File</button>
      </div>
      <div class="date-display" id="dateDisplay"></div>
      <div class="right-buttons">
        <div class="view-mode-group">
          <button id="btn-day" onclick="changeView('Day')" class="active">Day</button>
          <button id="btn-week" onclick="changeView('Week')">Week</button>
          <button id="btn-month" onclick="changeView('Month')">Month</button>
          <button id="btn-year" onclick="changeView('Year')">Year</button>
        </div>
        <div class="settings-container">
          <button class="settings-button" onclick="toggleSettings()">&#9881;</button>
          <div class="settings-dropdown" id="settingsDropdown">
            <button onclick="exportData()">Export JSON</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Gantt chart container -->
    <div id="gantt"></div>
    
    <!-- Analysis Panel below the timeline -->
    <div id="analysisPanel">
      <h3>Delay Analysis</h3>
      <p id="totalDelay">Total Delay Days: 0</p>
      <p id="averageDelay">Average Delay per Task: 0</p>
      <p id="delayedTasks">Number of Delayed Tasks: 0</p>
    </div>
    
    <!-- Edit Task Modal (Horizontal Form Layout) -->
    <div class="modal" id="taskModal">
      <div class="modal-content">
        <h2 id="modalTitle">Create New Task</h2>
        <form id="taskForm" class="form-horizontal">
          <div class="form-group">
            <label for="phaseName">Phase Name (optional):</label>
            <input type="text" id="phaseName" list="phasesList" />
            <datalist id="phasesList"></datalist>
          </div>
          <div class="form-group">
            <label for="taskName">Task Name:</label>
            <input type="text" id="taskName" required />
          </div>
          <div class="form-group">
            <label for="taskStart">Planned Start Date:</label>
            <input type="date" id="taskStart" required />
          </div>
          <div class="form-group">
            <label for="taskEnd">Planned End Date:</label>
            <input type="date" id="taskEnd" required />
          </div>
          <div class="form-group">
            <label for="actualStart">Actual Start Date:</label>
            <input type="date" id="actualStart" />
          </div>
          <div class="form-group">
            <label for="actualEnd">Actual End Date:</label>
            <input type="date" id="actualEnd" />
          </div>
          <!-- Status dropdown with fixed style choices -->
          <div class="form-group">
            <label for="taskStatus">Status:</label>
            <select id="taskStatus">
              <option value="not_started">Not Yet Started</option>
              <option value="in_progress">In Progress</option>
              <option value="completed">Completed</option>
              <option value="blocked">Blocked</option>
            </select>
          </div>
          <div class="form-group full-width">
            <label for="taskDependencies">Dependencies:</label>
            <select id="taskDependencies" multiple>
              <option value="">Select Dependencies</option>
            </select>
          </div>
          <div class="form-group full-width">
            <label for="taskNotes">Notes:</label>
            <textarea id="taskNotes" rows="4"></textarea>
          </div>
          <div class="button-group">
            <button type="submit">Save Task</button>
            <button type="button" onclick="closeModal()">Cancel</button>
          </div>
        </form>
      </div>
    </div>
    
    <!-- Task Details Modal (Vertical Layout remains unchanged) -->
    <div class="modal" id="detailsModal">
      <div class="modal-content">
        <h2 id="detailsTaskTitle">Task Details</h2>
        <p><strong>Phase:</strong> <span id="detailsPhase"></span></p>
        <p><strong>Planned Start:</strong> <span id="detailsStart"></span></p>
        <p><strong>Planned End:</strong> <span id="detailsEnd"></span></p>
        <p><strong>Actual Start:</strong> <span id="detailsActualStart"></span></p>
        <p><strong>Actual End:</strong> <span id="detailsActualEnd"></span></p>
        <p><strong>Status:</strong> <span id="detailsStatus"></span></p>
        <p><strong>Dependencies:</strong> <span id="detailsDependencies"></span></p>
        <p><strong>Notes:</strong></p>
        <p id="detailsNotes" style="white-space: pre-wrap; background:#f9f9f9; padding:8px; border:1px solid #ddd;"></p>
        <div class="button-group">
          <button id="editTaskButton" onclick="editTaskFromDetails(this.getAttribute('data-task-id'));">Edit Task</button>
          <button id="deleteTaskButton" onclick="deleteTask(this.getAttribute('data-task-id'));">Delete Task</button>
          <button type="button" onclick="closeDetailsModal()">Close</button>
        </div>
      </div>
    </div>
    
  </div>
  
  <!-- Include Frappe Gantt -->
  <script src="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>
  <script>
    // Global variables
    let tasks = [];
    let currentEditId = null;
    let fileHandle = null; // Holds the writable file handle for auto-saving
    let currentViewMode = 'Day';
    
    // Mapping of statuses to colors and labels.
    const statusColors = {
      not_started: "#808080",  // Gray
      in_progress: "#F9A825",  // Darker Yellow for better text contrast
      completed:   "#008000",  // Green
      blocked:     "#FF0000"   // Red
    };
    const statusLabels = {
      not_started: "Not Yet Started",
      in_progress: "In Progress",
      completed:   "Completed",
      blocked:     "Blocked"
    };
    
    // Auto-load tasks from localStorage.
    const savedTasks = localStorage.getItem('tasks');
    if (savedTasks) {
      tasks = JSON.parse(savedTasks);
    }
    
    // Save tasks to localStorage and, if available, to the designated auto-save file.
    async function saveTasks() {
      localStorage.setItem('tasks', JSON.stringify(tasks));
      if (fileHandle) {
        try {
          if (await fileHandle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
            const permission = await fileHandle.requestPermission({ mode: 'readwrite' });
            if (permission !== 'granted') {
              console.error('Write permission was not granted.');
              return;
            }
          }
          const writable = await fileHandle.createWritable();
          await writable.write(JSON.stringify(tasks, null, 2));
          await writable.close();
          console.log('Auto-saved to file.');
        } catch (err) {
          console.error('Error writing to file:', err);
        }
      }
    }
    
    // Use the File System Access API to load a file and set it as the auto-save file.
    async function loadAndSetAutoSaveFile() {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'JSON Files',
            accept: { 'application/json': ['.json'] }
          }],
          multiple: false
        });
        const permission = await handle.requestPermission({ mode: 'readwrite' });
        if (permission !== 'granted') {
          console.error('Write permission was not granted.');
          return;
        }
        fileHandle = handle;
        const fileData = await handle.getFile();
        const text = await fileData.text();
        try {
          tasks = JSON.parse(text);
          console.log('Loaded tasks from file.');
        } catch (e) {
          console.error('File does not contain valid JSON. Starting with empty task list.');
          tasks = [];
        }
        renderGantt();
      } catch (err) {
        console.error('Error loading file:', err);
      }
    }
    
    // Toggle settings dropdown visibility.
    function toggleSettings() {
      const dropdown = document.getElementById('settingsDropdown');
      dropdown.classList.toggle('show');
    }
    
    // Helper function to add ordinal suffix to a day.
    function getOrdinal(n) {
      const s = ["th", "st", "nd", "rd"];
      const v = n % 100;
      return n + (s[(v - 20) % 10] || s[v] || s[0]);
    }
    
    // Format a Date object as "Month DayOrdinal, Year" (e.g., "March 3rd, 2025")
    function formatDate(date) {
      const month = new Intl.DateTimeFormat('en-US', { month: 'long' }).format(date);
      const day = date.getDate();
      const year = date.getFullYear();
      return `${month} ${getOrdinal(day)}, ${year}`;
    }
    
    // Set today's date in the center of the toolbar.
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('dateDisplay').textContent = formatDate(new Date());
    });
    
    // Open the edit modal; pre-populate if editing an existing task.
    function openModal(taskId) {
      currentEditId = taskId;
      const modalTitle = document.getElementById('modalTitle');
      if (taskId) {
        modalTitle.textContent = "Edit Task";
        const task = tasks.find(t => t.id === taskId);
        document.getElementById('phaseName').value = task.phase || '';
        document.getElementById('taskName').value = task.name;
        document.getElementById('taskStart').value = task.start;
        document.getElementById('taskEnd').value = task.end;
        document.getElementById('actualStart').value = task.actualStart || '';
        document.getElementById('actualEnd').value = task.actualEnd || '';
        document.getElementById('taskNotes').value = task.notes || '';
        document.getElementById('taskStatus').value = task.status || "not_started";
      } else {
        modalTitle.textContent = "Create New Task";
        document.getElementById('taskForm').reset();
        document.getElementById('taskStatus').value = "not_started";
      }
      populateDependencies();
      populatePhasesList();
      document.getElementById('taskModal').style.display = 'block';
    }
    
    function closeModal() {
      document.getElementById('taskModal').style.display = 'none';
      currentEditId = null;
    }
    
    // Populate the datalist for phases.
    function populatePhasesList() {
      const phases = [...new Set(tasks.map(task => task.phase).filter(Boolean))];
      const datalist = document.getElementById('phasesList');
      datalist.innerHTML = phases.map(phase => `<option value="${phase}">${phase}</option>`).join('');
    }
    
    function exportData() {
      const dataStr = JSON.stringify(tasks, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tasks.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    // Populate the dependencies dropdown; exclude the current task if editing.
    function populateDependencies() {
      const select = document.getElementById('taskDependencies');
      select.innerHTML = '<option value="">Select Dependencies</option>';
      tasks.forEach(task => {
        if (currentEditId && task.id === currentEditId) return;
        const option = document.createElement('option');
        option.value = task.id;
        option.textContent = task.phase ? `${task.phase} - ${task.name}` : task.name;
        select.appendChild(option);
      });
    }
    
    // Render the Gantt chart along with delay overlays and update analysis.
    function renderGantt() {
      const ganttEl = document.getElementById('gantt');
      ganttEl.innerHTML = '';
      const phases = {};
      const ungroupedTasks = [];
      
      tasks.forEach(task => {
        if (task.phase) {
          if (!phases[task.phase]) {
            phases[task.phase] = { color: task.color, tasks: [] };
          }
          phases[task.phase].tasks.push(task);
        } else {
          ungroupedTasks.push(task);
        }
      });
      
      const formattedTasks = [];
      Object.entries(phases).forEach(([phaseName, phaseData]) => {
        formattedTasks.push({
          id: `phase-${phaseName}`,
          name: phaseName,
          start: getEarliestStart(phaseData.tasks),
          end: getLatestEnd(phaseData.tasks),
          progress: 0,
          custom_class: 'phase-header',
          isHeader: true
        });
        phaseData.tasks.forEach(task => {
          formattedTasks.push({
            id: task.id,
            name: task.name,
            start: task.start,
            end: task.end,
            dependencies: (task.dependencies || []).join(', '),
            progress: 0,
            color: task.color,
            custom_class: `task-${task.id}`
          });
        });
      });
      ungroupedTasks.forEach(task => {
        formattedTasks.push({
          id: task.id,
          name: task.name,
          start: task.start,
          end: task.end,
          dependencies: (task.dependencies || []).join(', '),
          progress: 0,
          color: task.color,
          custom_class: `task-${task.id}`
        });
      });
      
      const gantt = new Gantt('#gantt', formattedTasks, {
        view_mode: currentViewMode,
        on_click: (task) => {
          if (task.isHeader) return;
          showTaskDetails(task.id);
        },
        on_date_change: async (task, start, end) => {
          const updatedTask = tasks.find(t => t.id === task.id);
          if (updatedTask) {
            updatedTask.start = start;
            updatedTask.end = end;
            await saveTasks();
            renderGantt();
          }
        }
      });
      
      const style = document.createElement('style');
      tasks.forEach(task => {
        style.innerHTML += `
          .task-${task.id} rect.bar {
            fill: ${task.color} !important;
            stroke: ${task.color} !important;
          }
          .task-${task.id} rect.bar-progress {
            fill: ${task.color} !important;
          }
        `;
      });
      ganttEl.appendChild(style);
      
      setTimeout(addDelayOverlays, 50);
      updateAnalysisPanel();
    }
    
    function getEarliestStart(tasks) {
      return tasks.reduce((min, task) => task.start < min ? task.start : min, tasks[0].start);
    }
    function getLatestEnd(tasks) {
      return tasks.reduce((max, task) => task.end > max ? task.end : max, tasks[0].end);
    }
    
    // Draw red overlays for delay differences (planned vs. actual dates).
    function addDelayOverlays() {
      const svg = document.querySelector('#gantt svg');
      if (!svg) return;
      svg.querySelectorAll('.delay-overlay').forEach(el => el.remove());
      
      tasks.forEach(task => {
        if (!task.start || !task.end) return;
        const plannedStart = new Date(task.start);
        const plannedEnd = new Date(task.end);
        const actualStart = task.actualStart ? new Date(task.actualStart) : null;
        const actualEnd = task.actualEnd ? new Date(task.actualEnd) : null;
        const barRect = document.querySelector(`.task-${task.id} rect.bar`);
        if (!barRect) return;
        const barX = parseFloat(barRect.getAttribute('x'));
        const barWidth = parseFloat(barRect.getAttribute('width'));
        const barY = parseFloat(barRect.getAttribute('y'));
        const barHeight = parseFloat(barRect.getAttribute('height'));
        const plannedDuration = (plannedEnd - plannedStart) / 86400000;
        if (plannedDuration <= 0) return;
        const dayWidth = barWidth / plannedDuration;
        
        // Draw start delay overlay (always red)
        if (actualStart && actualStart > plannedStart) {
          const delayStartDays = (actualStart - plannedStart) / 86400000;
          const overlayWidth = delayStartDays * dayWidth;
          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", barX);
          rect.setAttribute("y", barY);
          rect.setAttribute("width", overlayWidth);
          rect.setAttribute("height", barHeight);
          rect.setAttribute("class", "delay-overlay");
          svg.appendChild(rect);
        }
        // Draw finish delay overlay (always red)
        if (actualEnd && actualEnd > plannedEnd) {
          const delayEndDays = (actualEnd - plannedEnd) / 86400000;
          const overlayWidth = delayEndDays * dayWidth;
          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", barX + barWidth);
          rect.setAttribute("y", barY);
          rect.setAttribute("width", overlayWidth);
          rect.setAttribute("height", barHeight);
          rect.setAttribute("class", "delay-overlay");
          svg.appendChild(rect);
        }
      });
    }
    
    // Update the analysis panel with delay statistics.
    function updateAnalysisPanel() {
      let totalDelay = 0;
      let delayedCount = 0;
      tasks.forEach(task => {
        const plannedStart = new Date(task.start);
        const plannedEnd = new Date(task.end);
        let taskDelay = 0;
        if (task.actualStart) {
          const actualStart = new Date(task.actualStart);
          if (actualStart > plannedStart) {
            taskDelay += (actualStart - plannedStart) / 86400000;
          }
        }
        if (task.actualEnd) {
          const actualEnd = new Date(task.actualEnd);
          if (actualEnd > plannedEnd) {
            taskDelay += (actualEnd - plannedEnd) / 86400000;
          }
        }
        if (taskDelay > 0) {
          delayedCount++;
          totalDelay += taskDelay;
        }
      });
      const averageDelay = delayedCount > 0 ? (totalDelay / delayedCount).toFixed(1) : 0;
      document.getElementById('totalDelay').textContent = "Total Delay Days: " + totalDelay.toFixed(1);
      document.getElementById('averageDelay').textContent = "Average Delay per Task: " + averageDelay;
      document.getElementById('delayedTasks').textContent = "Number of Delayed Tasks: " + delayedCount;
    }
    
    // Handle task form submission.
    document.getElementById('taskForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      const status = document.getElementById('taskStatus').value;
      const color = statusColors[status];
      const taskData = {
        id: currentEditId || Date.now().toString(),
        phase: document.getElementById('phaseName').value || null,
        name: document.getElementById('taskName').value,
        start: document.getElementById('taskStart').value,
        end: document.getElementById('taskEnd').value,
        actualStart: document.getElementById('actualStart').value || null,
        actualEnd: document.getElementById('actualEnd').value || null,
        status: status,
        color: color,
        dependencies: Array.from(document.getElementById('taskDependencies').selectedOptions)
                      .map(option => option.value)
                      .filter(Boolean),
        notes: document.getElementById('taskNotes').value
      };
      if (currentEditId) {
        const index = tasks.findIndex(t => t.id === currentEditId);
        tasks[index] = taskData;
      } else {
        tasks.push(taskData);
      }
      await saveTasks();
      closeModal();
      renderGantt();
    });
    
    // Switch view mode.
    function changeView(mode) {
      currentViewMode = mode;
      ['Day','Week','Month','Year'].forEach(m => {
        document.getElementById('btn-' + m.toLowerCase()).classList.toggle('active', m === mode);
      });
      renderGantt();
    }
    
    // Task Details Modal Functions.
    function showTaskDetails(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      document.getElementById('detailsTaskTitle').textContent = task.name;
      document.getElementById('detailsPhase').textContent = task.phase || 'None';
      document.getElementById('detailsStart').textContent = task.start;
      document.getElementById('detailsEnd').textContent = task.end;
      document.getElementById('detailsActualStart').textContent = task.actualStart || 'N/A';
      document.getElementById('detailsActualEnd').textContent = task.actualEnd || 'N/A';
      document.getElementById('detailsStatus').textContent = statusLabels[task.status] || task.status;
      const dependencyNames = task.dependencies && task.dependencies.length 
        ? task.dependencies.map(depId => {
            const depTask = tasks.find(t => t.id === depId);
            return depTask ? depTask.name : depId;
          }).join(', ')
        : 'None';
      document.getElementById('detailsDependencies').textContent = dependencyNames;
      document.getElementById('detailsNotes').textContent = task.notes || 'No notes';
      document.getElementById('editTaskButton').setAttribute('data-task-id', taskId);
      document.getElementById('deleteTaskButton').setAttribute('data-task-id', taskId);
      document.getElementById('detailsModal').style.display = 'block';
    }
    
    function closeDetailsModal() {
      document.getElementById('detailsModal').style.display = 'none';
    }
    
    function editTaskFromDetails(taskId) {
      closeDetailsModal();
      openModal(taskId);
    }
    
    // Delete task functionality.
    function deleteTask(taskId) {
      if (!confirm("Are you sure you want to delete this task?")) return;
      tasks = tasks.filter(t => t.id !== taskId);
      tasks.forEach(task => {
        if (task.dependencies && task.dependencies.length) {
          task.dependencies = task.dependencies.filter(depId => depId !== taskId);
        }
      });
      saveTasks().then(() => {
        closeDetailsModal();
        renderGantt();
      });
    }
    
    // Initial rendering.
    renderGantt();
  </script>
</body>
</html>
